name: Package and Release

# TRIGGERS:
# - GitHub Release creation ‚Üí RELEASE builds and CurseForge uploads
# - Pushes to main ‚Üí RELEASE builds and direct CurseForge uploads
# - Pushes to feature/develop branches ‚Üí ALPHA builds

on:
  release:
    types: [published]    # Trigger on release creation
  push:
    branches:
      - main               # Auto-create GitHub Release (which triggers CurseForge upload)
      - develop            # Alpha builds
      - 'feature/**'
      - 'hotfix/**' 
      - 'release/**'
      - '*'

env:
  GAME_VERSIONS: "5.5.0,11.2.5,1.15.7,3.4.5,4.4.2,2.5.4,2.5.5"  # MOP Classic

jobs:
  package:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to create tags and releases
      actions: read    # Required to read workflow context
    outputs:
      release-type: ${{ steps.release-type.outputs.RELEASE_TYPE }}
      version: ${{ steps.release-type.outputs.VERSION }}
      is-tagged: ${{ steps.release-type.outputs.IS_TAGGED }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper versioning
          submodules: recursive
          token: ${{ secrets.GITHUB_TOKEN }}  # Ensure we can push tags
          
      - name: Determine release type and version
        id: release-type
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Branch/Tag: ${{ github.ref_name }}"
          echo "Ref: ${{ github.ref }}"
          
          # Determine release type based on event type
          if [[ "${{ github.event_name }}" == "release" ]]; then
            # GitHub Release was created - this is always a RELEASE build
            echo "Debug: Processing GitHub Release event"
            RELEASE_TYPE="release"
            
            # Extract version from release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION="${RELEASE_TAG#v}"  # Remove v prefix if present
            IS_TAGGED="true"           # Release creation already created the tag
            SHOULD_CREATE_TAG="false"  # Tag already exists
            
            echo "Debug: Release event - TAG=${RELEASE_TAG}, VERSION=${VERSION}"
            
            # Determine release vs pre-release
            if [[ "${RELEASE_TAG}" == *"alpha"* ]]; then
              RELEASE_TYPE="alpha"
              echo "Debug: Detected alpha release"
            elif [[ "${RELEASE_TAG}" == *"beta"* ]]; then
              RELEASE_TYPE="beta"
              echo "Debug: Detected beta release"
            else
              RELEASE_TYPE="release"
              echo "Debug: Detected stable release"
            fi
            
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            BRANCH_NAME="${{ github.ref_name }}"
            echo "Debug: Processing push to branch '${BRANCH_NAME}'"
            
            if [[ "${BRANCH_NAME}" == "main" ]]; then
              # Main branch push - direct release packaging
              echo "Debug: Main branch push - will package as release"
              RELEASE_TYPE="release"  # Direct release build
              BASE_VERSION=$(grep "## Version:" GuildAchieves.toc | sed 's/## Version: //' | xargs)
              
              # For main branch pushes, DON'T create tags during CI
              # This avoids "future tag" detection by BigWigsMods packager
              echo "üîç Main branch push - packaging without tag creation"
              
              # Check for existing tags to determine version, but don't create new ones
              git fetch --tags origin
              BASE_TAG_NAME="v${BASE_VERSION}"
              if git rev-parse --verify "refs/tags/${BASE_TAG_NAME}" >/dev/null 2>&1; then
                echo "‚ö†Ô∏è  Base tag ${BASE_TAG_NAME} exists, finding hotfix suffix..."
                
                SUFFIX=""
                for letter in a b c d e f g h i j k l m n o p q r s t u v w x y z; do
                  CANDIDATE_TAG="${BASE_TAG_NAME}${letter}"
                  if ! git rev-parse --verify "refs/tags/${CANDIDATE_TAG}" >/dev/null 2>&1; then
                    SUFFIX="${letter}"
                    VERSION="${BASE_VERSION}${letter}"
                    break
                  fi
                done
                
                if [[ -z "${SUFFIX}" ]]; then
                  echo "‚ùå Could not find available hotfix suffix after trying a-z"
                  exit 1
                fi
                
                echo "‚úÖ Using hotfix suffix '${SUFFIX}': ${VERSION}"
              else
                echo "‚úÖ Base version ${BASE_VERSION} is available"
                VERSION="${BASE_VERSION}"
              fi
              
              IS_TAGGED="false"
              SHOULD_CREATE_TAG="false"  # DON'T create tags during CI for main branch
              echo "Debug: Main branch - will package as release ${VERSION} WITHOUT tag creation"
              
            else
              # Feature/develop branches - alpha builds
              RELEASE_TYPE="alpha"
              BASE_VERSION=$(grep "## Version:" GuildAchieves.toc | sed 's/## Version: //' | xargs)
              VERSION="${BASE_VERSION}-dev-${BRANCH_NAME//\//-}"  # Include branch name for clarity
              IS_TAGGED="false"
              SHOULD_CREATE_TAG="false"
              
              echo "Debug: Feature branch build - RELEASE_TYPE=${RELEASE_TYPE}, VERSION=${VERSION}"
            fi
            
          else
            echo "‚ùå Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi
          
          echo "RELEASE_TYPE=${RELEASE_TYPE}" >> $GITHUB_OUTPUT
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT  
          echo "IS_TAGGED=${IS_TAGGED}" >> $GITHUB_OUTPUT
          echo "SHOULD_CREATE_TAG=${SHOULD_CREATE_TAG}" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è  Release Type: ${RELEASE_TYPE}"
          echo "üì¶  Version: ${VERSION}"
          echo "üè∑Ô∏è  Is Tagged: ${IS_TAGGED}"
          echo "üè∑Ô∏è  Should Create Tag: ${SHOULD_CREATE_TAG}"
          
      - name: Create git tag for release builds  
        if: steps.release-type.outputs.SHOULD_CREATE_TAG == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.release-type.outputs.VERSION }}"
          TAG_NAME="v${VERSION}"
          
          echo "üè∑Ô∏è Creating git tag for release build"
          echo "üì¶ Version: ${VERSION}"
          echo "üè∑Ô∏è Tag: ${TAG_NAME}"
          
          # Check if tag already exists
          if git rev-parse --verify "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Tag ${TAG_NAME} already exists, will use existing tag"
          else
            # Create and push the tag
            git tag "${TAG_NAME}"
            git push origin "${TAG_NAME}"
            echo "‚úÖ Created and pushed tag: ${TAG_NAME}"
            
            # Wait for git sync and verify tag availability
            echo "‚è≥ Waiting for git synchronization..."
            sleep 5
            
            # Fetch all tags to ensure sync
            git fetch --tags --force
            
            # Verify tag is available and at correct commit
            if git rev-parse --verify "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
              TAG_COMMIT=$(git rev-parse "refs/tags/${TAG_NAME}")
              HEAD_COMMIT=$(git rev-parse HEAD)
              if [[ "${TAG_COMMIT}" == "${HEAD_COMMIT}" ]]; then
                echo "‚úÖ Tag ${TAG_NAME} verified at correct commit: ${TAG_COMMIT}"
              else
                echo "‚ö†Ô∏è Tag commit (${TAG_COMMIT}) differs from HEAD (${HEAD_COMMIT})"
                exit 1
              fi
            else
              echo "‚ùå Tag ${TAG_NAME} verification failed after creation"
              exit 1
            fi
          fi
          
          echo "üöÄ Tag verified and ready for packaging"
          
      - name: Update TOC version for dev builds
        if: steps.release-type.outputs.RELEASE_TYPE == 'alpha' && steps.release-type.outputs.IS_TAGGED == 'false'
        run: |
          # Update version in TOC file for dev builds  
          sed -i "s/## Version: .*/## Version: ${{ steps.release-type.outputs.VERSION }}/" GuildAchieves.toc
          echo "Updated TOC version to: ${{ steps.release-type.outputs.VERSION }}"
          
      - name: Pre-packaging git synchronization
        if: steps.release-type.outputs.RELEASE_TYPE != 'skip' && !(steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main')
        run: |
          echo "üîÑ Synchronizing git state for packager..."
          
          # Ensure we have the latest tags and refs
          git fetch --all --tags --force --prune
          
          # For release builds, verify tag exists and points to current commit
          if [[ "${{ steps.release-type.outputs.RELEASE_TYPE }}" == "release" ]]; then
            EXPECTED_TAG="v${{ steps.release-type.outputs.VERSION }}"
            echo "üîç Verifying release tag: ${EXPECTED_TAG}"
            
            if git rev-parse --verify "refs/tags/${EXPECTED_TAG}" >/dev/null 2>&1; then
              TAG_COMMIT=$(git rev-parse "refs/tags/${EXPECTED_TAG}")
              HEAD_COMMIT=$(git rev-parse HEAD)
              
              echo "üè∑Ô∏è Tag commit: ${TAG_COMMIT}"
              echo "üìç HEAD commit: ${HEAD_COMMIT}"
              
              if [[ "${TAG_COMMIT}" == "${HEAD_COMMIT}" ]]; then
                echo "‚úÖ Tag points to current commit"
              else
                echo "‚ùå Tag-commit mismatch detected"
                echo "This may cause 'future tag' errors in the packager"
                exit 1
              fi
            else
              echo "‚ùå Expected tag ${EXPECTED_TAG} not found"
              exit 1
            fi
          fi
          
          echo "‚úÖ Git state synchronized and verified"
          
      - name: Pre-packaging verification
        if: steps.release-type.outputs.RELEASE_TYPE != 'skip' && !(steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main')
        run: |
          echo "üîç Pre-packaging state check:"
          echo "üìã Release Type: ${{ steps.release-type.outputs.RELEASE_TYPE }}"
          echo "üìù Version: ${{ steps.release-type.outputs.VERSION }}"
          echo "üè∑Ô∏è Is Tagged: ${{ steps.release-type.outputs.IS_TAGGED }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üîó Ref: ${{ github.ref }}"
          echo "üì¶ Package name will be: GuildAchieves-v${{ steps.release-type.outputs.VERSION }}"
          echo "üè∑Ô∏è Current git tags on HEAD:"
          git tag --points-at HEAD || echo "‚ùå No tags found on HEAD"
          echo "üè∑Ô∏è Tag detection by git describe:"
          git describe --tags --exact-match HEAD 2>/dev/null && echo "‚úÖ Tag detected" || echo "‚ùå No exact tag match"
          echo "üè∑Ô∏è Git status:"
          git status --porcelain || echo "Working tree clean"
          echo "üïê Current system time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üîë CF_API_KEY present: ${{ secrets.CF_API_KEY != '' }}"
          echo ""
          echo "üöÄ Launching BigWigsMods packager..."
          
      - name: Final packager preparation
        if: steps.release-type.outputs.RELEASE_TYPE != 'skip' && !(steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main')
        run: |
          echo "üîß Final preparation for BigWigsMods packager..."
          
          # Ensure we're on the correct commit for release builds
          if [[ "${{ steps.release-type.outputs.RELEASE_TYPE }}" == "release" ]]; then
            EXPECTED_TAG="v${{ steps.release-type.outputs.VERSION }}"
            echo "üìç Checking out tag: ${EXPECTED_TAG}"
            git checkout "${EXPECTED_TAG}"
            
            # Verify we're at the expected commit
            CURRENT_COMMIT=$(git rev-parse HEAD)
            TAG_COMMIT=$(git rev-parse "${EXPECTED_TAG}")
            
            if [[ "${CURRENT_COMMIT}" == "${TAG_COMMIT}" ]]; then
              echo "‚úÖ Successfully checked out tag commit: ${CURRENT_COMMIT}"
            else
              echo "‚ùå Checkout verification failed"
              exit 1
            fi
          fi
          
          echo "‚úÖ Ready for packaging"
          
      - name: Skip packaging for main branch (GitHub Release will trigger it)
        if: steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main'
        run: |
          echo "üîÑ Main branch push detected - creating GitHub Release instead of direct packaging"
          echo "üìã This will trigger a release event that handles packaging with proper tag timing"
          echo "üöÄ GitHub Release creation will follow, triggering the release workflow"
          echo "‚úÖ This avoids 'future tag' issues with BigWigsMods packager"
          
      - name: Package addon
        if: steps.release-type.outputs.RELEASE_TYPE != 'skip' && !(steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main')
        uses: BigWigsMods/packager@v2
        with:
          args: -g ${{ env.GAME_VERSIONS }} -p 1416033 -n "GuildAchieves-v${{ steps.release-type.outputs.VERSION }}"
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          GITHUB_OAUTH: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Debug packaging results
        if: always()
        run: |
          echo "üîë CF_API_KEY present: ${{ secrets.CF_API_KEY != '' }}"
          echo "üéØ Game versions: ${{ env.GAME_VERSIONS }}"
          echo "üÜî CurseForge Project ID: 1416033"
          echo "üìã Our release type determination: ${{ steps.release-type.outputs.RELEASE_TYPE }}"
          echo "üìù Final version used: ${{ steps.release-type.outputs.VERSION }}"
          echo "üè∑Ô∏è Is Tagged: ${{ steps.release-type.outputs.IS_TAGGED }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üîó Ref: ${{ github.ref }}"
          
          if [[ "${{ steps.release-type.outputs.RELEASE_TYPE }}" == "release" && "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "main" ]]; then
            echo ""
            echo "üîÑ MAIN BRANCH WORKFLOW:"
            echo "   ‚úÖ Created GitHub Release ‚Üí Will trigger release event"
            echo "   ‚è≥ Release event will handle CurseForge packaging"
            echo "   üéØ This avoids 'future tag' detection issues"
            echo ""
            echo "üîó Check for new GitHub Release at: https://github.com/${{ github.repository }}/releases"
            echo "üîó After release event runs, check CurseForge: https://www.curseforge.com/wow/addons/guild-achieves/files"
          else
            echo "üì¶ Direct packaging completed"
            echo "üîß Packager args used: -g ${{ env.GAME_VERSIONS }} -p 1416033 -n GuildAchieves-v${{ steps.release-type.outputs.VERSION }}"
            echo "üè∑Ô∏è Git tags on current commit:"
            git tag --points-at HEAD || echo "No tags found"
            echo "üè∑Ô∏è Recent git tags for this version family:"
            CURRENT_VERSION="${{ steps.release-type.outputs.VERSION }}"
            BASE_VERSION=$(echo "${CURRENT_VERSION}" | sed 's/[a-z]*$//')
            git tag --sort=-version:refname | grep -E "^v?${BASE_VERSION}[a-z]*$" | head -5 || echo "No matching tags found"
            echo ""
            echo "üîó Check uploads at: https://www.curseforge.com/wow/addons/guild-achieves/files"
            echo "üìÅ Looking for .zip files:"
            find . -name "*.zip" 2>/dev/null || echo "No zip files found"
          fi
          
          echo ""
          echo "‚ÑπÔ∏è  Release Process Summary:"
          echo "   - GitHub Release creation ‚Üí Automatic CurseForge upload via release event"
          echo "   - Main branch push ‚Üí Creates GitHub Release ‚Üí Triggers release event ‚Üí CurseForge upload"  
          echo "   - Feature branches ‚Üí Direct alpha builds to CurseForge"
          
      - name: Extract changelog for current version
        id: changelog
        if: steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name != 'release'
        run: |
          # Extract the changelog content for the current version
          RELEASE_VERSION="${{ steps.release-type.outputs.VERSION }}"
          
          # For hotfix versions (1.0.0a, 1.0.0b, etc.), use the base version (1.0.0) for changelog
          BASE_VERSION=$(echo "${RELEASE_VERSION}" | sed 's/[a-z]*$//')
          echo "üìù Release version: ${RELEASE_VERSION}"
          echo "üìù Using base version for changelog: ${BASE_VERSION}"
          
          # Check if CHANGELOG.txt exists
          if [[ -f "CHANGELOG.txt" ]]; then
          # Read changelog and extract content for the base version
          awk -v version="$BASE_VERSION" '
          BEGIN { 
            found = 0; 
            content = ""; 
            in_version = 0;
          }
          /^## Version / { 
            if (found && in_version) {
              # We hit the next version, stop processing
              exit;
            }
            if ($0 ~ version || gsub(/^## Version /, "") == version) {
              found = 1; 
              in_version = 1;
              next; # Skip the version header itself
            }
          }
          found && in_version { 
            if (content != "") content = content "\n";
            content = content $0;
          }
          END { 
            if (content != "") {
              print content;
            } else {
              print "No changelog content found for version " version;
            }
          }
          ' CHANGELOG.txt > changelog_content.txt
          else
            echo "Initial release of Guild Achieve Congratulator - Automatically congratulates guildies on achievements with humorous messages!" > changelog_content.txt
          fi
          
          # Store the changelog content in output
          {
            echo 'CHANGELOG_CONTENT<<EOF'
            cat changelog_content.txt
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          echo "üìù Extracted changelog for release ${RELEASE_VERSION} using base version ${BASE_VERSION}"
          echo "Preview:"
          head -10 changelog_content.txt
          
      - name: Extract release description for release events
        id: release-description
        if: github.event_name == 'release'
        env:
          RELEASE_BODY: ${{ github.event.release.body }}
        run: |
          # For release events, use the release body as changelog content
          echo "üìù Using GitHub Release description as changelog content"
          {
            echo 'CHANGELOG_CONTENT<<EOF'
            printf '%s\n' "$RELEASE_BODY"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
      - name: Create GitHub Release for main branch pushes (triggers packaging via release event)
        if: steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.release-type.outputs.VERSION }}
          name: Guild Achieve Congratulator v${{ steps.release-type.outputs.VERSION }}
          body: |
            ## Guild Achieve Congratulator v${{ steps.release-type.outputs.VERSION }}
            
            ${{ steps.changelog.outputs.CHANGELOG_CONTENT || steps.release-description.outputs.CHANGELOG_CONTENT }}
            
            ---
            
            ### üì¶ Installation
            1. Download the latest release
            2. Extract to your WoW AddOns folder  
            3. Restart World of Warcraft
            
            ### üéÆ Supported Versions
            - **Mists of Pandaria Classic** (5.5.0) 
            - **World of Warcraft Retail** (11.2.5+)
            
            ### üì• Download
            Available on [CurseForge](https://www.curseforge.com/wow/addons/guild-achieves)
            
            ### üìã Full Changelog
            See [CHANGELOG.txt](https://github.com/${{ github.repository }}/blob/v${{ steps.release-type.outputs.VERSION }}/CHANGELOG.txt) for complete version history.
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          
      - name: Fallback packaging if PAT_TOKEN not available  
        if: steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main'
        uses: BigWigsMods/packager@v2
        with:
          args: -g ${{ env.GAME_VERSIONS }} -p 1416033 -n "GuildAchieves-v${{ steps.release-type.outputs.VERSION }}"
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          GITHUB_OAUTH: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Fallback notification
        if: steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name == 'push' && github.ref_name == 'main'
        run: |
          echo "üîß Direct CurseForge packaging completed"
          echo "‚úÖ Check CurseForge for upload: https://www.curseforge.com/wow/addons/guild-achieves/files"
          echo ""
          echo "üí° For automatic release event triggering, configure PAT_TOKEN:"
          echo "   1. Go to GitHub ‚Üí Settings ‚Üí Developer settings ‚Üí Personal access tokens"
          echo "   2. Create token with 'contents:write' and 'metadata:read' permissions"
          echo "   3. Add as repository secret named 'PAT_TOKEN'"
          echo "   4. This enables GitHub Release creation to trigger release events"
          
      - name: Send Discord Notification
        if: github.event_name == 'release'
        run: |
          # Extract changelog summary for Discord
          VERSION="${{ steps.release-type.outputs.VERSION }}"
          
          # For hotfix versions, always use base version for changelog lookup
          BASE_VERSION=$(echo "${VERSION}" | sed 's/[a-z]*$//')
          IS_HOTFIX=""
          if [[ "${VERSION}" != "${BASE_VERSION}" ]]; then
            IS_HOTFIX="true"
            echo "üîç Hotfix detected: ${VERSION} ‚Üí using base version ${BASE_VERSION} for changelog"
          fi
          
          # Create Discord-friendly changelog summary using pre-defined summaries
          # This avoids parsing issues with special characters in changelog
          case "$BASE_VERSION" in
            "1.0.0")
              cat > /tmp/changelog_summary.txt << 'SUMMARY_EOF'
          **INITIAL RELEASE** - The Guild Achieve Congratulator is here!
          
          **üéâ 100 Unique Messages Per Category** - Sarcastic, funny congratulations for every achievement type
          **üéØ Level Milestones** - Extra roasts for Levels 10-90, including the infamous 85-90 grind
          **‚öôÔ∏è Customizable Settings** - Toggle categories, adjust delay, test messages
          **üó∫Ô∏è Minimap Button** - Quick access to all settings
          
          **Over 2,000 unique messages** across all categories!
          SUMMARY_EOF
              ;;
            "1.1.0")
              cat > /tmp/changelog_summary.txt << 'SUMMARY_EOF'
          **SMART BATCHING UPDATE** - No more spam!
          
          **üéØ Smart Achievement Batching** - 3-second collection window before responding
          **üéâ Combo Messages** - One player earning multiple achievements gets ONE funny combined message
          **üèÜ Group Celebrations** - Raid boss kill sends ONE epic message instead of 25 spam messages
          **üìä New Messages** - 40 combo + 110 group celebration messages added
          
          **950+ total unique messages!**
          SUMMARY_EOF
              ;;
            "1.1.1")
              cat > /tmp/changelog_summary.txt << 'SUMMARY_EOF'
          **BUG FIX** - Self-Congratulation Fix
          
          üêõ **Fixed:** The addon no longer congratulates yourself when earning multiple achievements at once, even when "Congratulate Yourself" is disabled.
          
          The CongratsSelf setting is now properly respected for single achievements, multi-achievements, AND group achievements.
          SUMMARY_EOF
              ;;
            *)
              cat > /tmp/changelog_summary.txt << 'SUMMARY_EOF'
          New version released with improvements and fixes! Check the changelog for details.
          SUMMARY_EOF
              ;;
          esac
          
          # Add hotfix indicator if needed
          if [[ "$IS_HOTFIX" == "true" ]]; then
            HOTFIX_SUFFIX=$(echo "${VERSION}" | sed "s/^${BASE_VERSION}//")
            echo "" >> /tmp/changelog_summary.txt
            echo "üîß **Hotfix ${HOTFIX_SUFFIX}**: Bug fixes and stability improvements" >> /tmp/changelog_summary.txt
          fi
          
          # Get current date and create JSON payload
          CURRENT_DATE=$(date -u '+%B %d, %Y')
          CURRENT_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.000Z)
          
          echo "üîç Discord notification details:"
          echo "üì¶ Version: v$VERSION"
          echo "üìã Base version for changelog: $BASE_VERSION"
          echo "üîß Is hotfix: ${IS_HOTFIX:-false}"
          echo "üìù Changelog summary preview:"
          head -3 /tmp/changelog_summary.txt
          
          # Create version description
          VERSION_DESCRIPTION="A new version of Guild Achieve Congratulator has been released!"
          if [[ "$IS_HOTFIX" == "true" ]]; then
            HOTFIX_SUFFIX=$(echo "${VERSION}" | sed "s/^${BASE_VERSION}//")
            VERSION_DESCRIPTION="Hotfix ${HOTFIX_SUFFIX} released with bug fixes and improvements!"
          fi
          
          # Create field name for changelog
          if [[ "$IS_HOTFIX" == "true" ]]; then
            CHANGELOG_FIELD_NAME="üìã Changelog (v${BASE_VERSION} features)"
          else
            CHANGELOG_FIELD_NAME="üìã Changelog Summary"
          fi
          
          # Create Discord webhook payload using jq with proper multiline handling
          jq -n \
            --arg title "üèÜ Guild Achieve Congratulator - New Release Available!" \
            --arg description "$VERSION_DESCRIPTION" \
            --arg version "v$VERSION" \
            --arg date "$CURRENT_DATE" \
            --arg changelog_field_name "$CHANGELOG_FIELD_NAME" \
            --rawfile changelog /tmp/changelog_summary.txt \
            --arg timestamp "$CURRENT_TIMESTAMP" \
            '{
              "embeds": [{
                "title": $title,
                "description": $description,
                "color": 16766720,
                "fields": [
                  {
                    "name": "üì¶ Version",
                    "value": $version,
                    "inline": true
                  },
                  {
                    "name": "üìÖ Release Date", 
                    "value": $date,
                    "inline": true
                  },
                  {
                    "name": "üìà Downloads",
                    "value": "[CurseForge Page](https://www.curseforge.com/wow/addons/guild-achieves)",
                    "inline": true
                  },
                  {
                    "name": $changelog_field_name,
                    "value": $changelog,
                    "inline": false
                  }
                ],
                "footer": {
                  "text": "Guild Achieve Congratulator",
                  "icon_url": "https://media.forgecdn.net/avatars/thumbnails/1585/780/64/64/639026285156936467.png"
                },
                "timestamp": $timestamp
              }]
            }' > discord_payload.json
          
          # Clean up temp file
          rm -f /tmp/changelog_summary.txt
          
          echo "üìã Discord payload created:"
          head -10 discord_payload.json
          
          # Send to Discord webhook
          echo "üöÄ Sending Discord notification..."
          DISCORD_RESPONSE=$(curl -s -w "%{http_code}" -H "Content-Type: application/json" \
               -X POST \
               -d @discord_payload.json \
               "${{ secrets.DISCORD_WEBHOOK }}")
          
          HTTP_CODE=${DISCORD_RESPONSE: -3}
          RESPONSE_BODY=${DISCORD_RESPONSE%???}
          
          if [[ "$HTTP_CODE" -eq 204 ]]; then
            echo "‚úÖ Discord notification sent successfully for version $VERSION"
          else
            echo "‚ùå Discord webhook failed with HTTP $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            # Don't fail the workflow for Discord issues
          fi
          
  build-summary:
    runs-on: ubuntu-latest
    needs: package
    if: always()
    
    steps:
      - name: Build Summary
        run: |
          echo "## üì¶ Guild Achieve Congratulator Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch/Tag:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.package.outputs.version || '‚ùì Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Versions:** MOP 5.5.0, Retail 11.2.5+" >> $GITHUB_STEP_SUMMARY
          echo "**CurseForge Project:** 1416033 (guild-achieves)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Explain CurseForge release type
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "**CurseForge Release Type:** üü¢ Release" >> $GITHUB_STEP_SUMMARY
            echo "*(Triggered by GitHub Release creation)*" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.package.outputs.release-type }}" == "release" && "${{ github.event_name }}" == "push" ]]; then
            echo "**CurseForge Release Type:** üü¢ Release (from main branch push)" >> $GITHUB_STEP_SUMMARY
            echo "*(Direct release packaging from main branch)*" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            echo "**CurseForge Release Type:** üü° Alpha (feature branch)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**CurseForge Release Type:** üü° Alpha (feature branch)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.package.result }}" == "success" ]]; then
            echo "### ‚úÖ Build Status: Success" >> $GITHUB_STEP_SUMMARY
            
            if [[ "${{ github.event_name }}" == "release" ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üöÄ **Release build** - Available on [CurseForge](https://www.curseforge.com/wow/addons/guild-achieves)" >> $GITHUB_STEP_SUMMARY
            elif [[ "${{ needs.package.outputs.release-type }}" == "release" && "${{ github.event_name }}" == "push" ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üöÄ **Release build** - Available on [CurseForge](https://www.curseforge.com/wow/addons/guild-achieves)" >> $GITHUB_STEP_SUMMARY
              echo "Uploaded directly from main branch push" >> $GITHUB_STEP_SUMMARY
            else
              echo "" >> $GITHUB_STEP_SUMMARY  
              echo "üß™ **Alpha build** - Available on [CurseForge](https://www.curseforge.com/wow/addons/guild-achieves) for testing" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ùå Build Status: Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the package job logs for details." >> $GITHUB_STEP_SUMMARY
          fi
